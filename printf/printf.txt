문장이 있을 때, 널문자 만날 때까지 while문 돌림
    -> %를 만나지 않는다면 ft_putchar로 하나씩 출력
    -> %를 만나면 어떤 플래그이고 서식지정자인지 확인하러 감
	-> %다음이 바로 %라면 ft_putchar로 %출력하고 return 0
	-> %가 아니면 서식지정자 나올 때까지 플래그 구조체에 어떤 플래그인지 저장
		-> 서식지정자를 만나면 어떤 서식지정자인지 확인(스위치문 사용하면 될 듯) 
			-> 해당 서식지정자 인덱스로 함수포인터배열에서 해당하는 서식지정자 처리할 함수 불러옴

------

%[flag][width][.precision][length]서식지정자

printf 구현할 서식지정자
- c : 문자
- s : 문자열
- p : 포인터 주소
- d : 부호 있는 십진법 정수
- i : 부호 있는 십진법 정수
- u : 부호없는 십진법 정수
- x : 부호없는 16진법 정수(소문자)
- X : 부호없는 16진법 정수(대문자)
- % : %%면 %를 출력

-> i와 d의 차이 : scanf에서 i는 10, 16, 8진수 다 받을 수 있고, d는 10진수만 받음. 즉, printf에서는 차이 없음


----------

c : void c_format(char c, t_info *info)
ex) c_format(va_arg(ap, char), &info);

-----------------------------------------------------------------------------

플래그
- - : 필드에서 값을 왼쪽으로 정렬하는 플래그(cspdiuxX등 대부분)
- 0 : 오른쪽 정렬일 때 공백을 0으로 메움(diuxX등 정수형)
- . : .n (n은 10진수) 일 때, 소수점 이하의 자릿수를 n만큼 나오도록 함(정수형, 실수형, 문자열만)
- * : width나 .처럼 숫자가 필요한 옵션에서, 숫자를 *로 대체. 가변인수로 *에 값을 전달

-> -와 0이 둘 다 있을 때는 0무시하고 -로 표시

-------

플래그 구현

align(t_info *info) -> -와 0 처리 함수
sign(t_info *info) -> 공백과 +처리 함수



---------------------------------------------------------------------------------

보너스
- n : 출력X, %n이 나올 때까지 출력한 문자의 수를 n에 저장함(n은 int형 포인터) ... ex) int num = 125; int *ptr; printf("Hello %d!!%n\n", num, ptr); 하면 ptr에는 11이 저장됨(Hello 125!!)
- f : 십진법 부동소수점 수
- g : %e나 %f보다 간략히 출력
- e : 지수 표기법으로 출력
- l
- ll
- h
- hh


플래그
- # : 8진수면 정수값 앞에 0, 16진수 소문자 출력이면 0x, 16진수 대문자 출력이면 0X 출력
- 공백 : 양수일 때는 +부호 대신 공백 출력, 음수일 때는 -부호 출력
- + : 양수일 때는 +부호 출력, 음수일 때는 -부호 출력

-> 공백과 + 둘 다 있으면 공백 무시하고 +로 표시


->> flag는 하나씩

%-0# +*.*d
%-0# +5.5d



-------------------------------------------------------------------

%s
- precision값이 양수이고 문자열 길이보다 작으면 precision값만큼 출력
- precision값이 음수면 문자열 전체 출력
- -플래그가 있으면 왼쪽 정렬
- -플래그가 없고, precision도 없고, 0플래그가 있으면 width - size만큼 0 출력
- 원래는 0플래그 안 쓰는데 테스터에서는 돌려서 처리함
- null이면 (null)출력


%p